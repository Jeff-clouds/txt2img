<!-- Version 1.4 -->
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1. ç”Ÿæˆå›¾ç‰‡-2.é•¿æŒ‰å›¾ç‰‡ä¿å­˜</title>
    <link rel="stylesheet" href="../styles/shared.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div id="mainPage">
        <div class="button-area">
            <div class="settings-area">
                <div class="input-group">
                    <label for="emojiInput">è¡¨æƒ…ç¬¦å·:</label>
                    <input type="text" id="emojiInput" value="ğŸ± ğŸ± ğŸ± ğŸ± ğŸ±" placeholder="è¾“å…¥è¡¨æƒ…ç¬¦å·">
                </div>
                <div class="input-group">
                    <label for="watermarkInput">æ°´å°æ–‡æœ¬:</label>
                    <input type="text" id="watermarkInput" value="æ°´å°" placeholder="è¾“å…¥æ°´å°æ–‡æœ¬">
                </div>
            </div>
            <div class="button-group">
                <button class="preview-btn" onclick="previewMarkdown()">é¢„è§ˆæ¸²æŸ“æ•ˆæœ</button>
                <button class="generate-btn" onclick="generateImage()" style="display: none;">ç”Ÿæˆå›¾ç‰‡</button>
                <a href="../index.html" style="color: #8b949e; text-decoration: none; margin-left: 20px;">è¿”å›ä¸»é¡µ</a>
            </div>
        </div>
        <div class="content-area">
            <div class="content-wrapper">
                <div class="emoji-container">
                    <span class="emoji">ğŸ±</span>
                    <span class="emoji">ğŸ±</span>
                    <span class="emoji">ğŸ±</span>
                    <span class="emoji">ğŸ±</span>
                    <span class="emoji">ğŸ±</span>
                </div>
                <div class="card">
                    <div class="timestamp"></div>
                    <div class="card-text" contenteditable="true">æ­£æ–‡</div>
                    <div class="rendered-content" style="display: none;"></div>
                    <div class="stats"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="imagePage">
        <div class="button-group">
            <button class="download-btn" onclick="downloadAllImages()">ä¸‹è½½å…¨éƒ¨å›¾ç‰‡</button>
            <a href="../index.html" style="color: #8b949e; text-decoration: none; margin-left: 20px;">è¿”å›ä¸»é¡µ</a>
        </div>
        <div id="generatedImages"></div>
    </div>

    <script>
        // ç›‘å¬æ–‡æœ¬å˜åŒ–ï¼Œè°ƒæ•´å®¹å™¨é«˜åº¦å’Œæ›´æ–°å­—æ•°ç»Ÿè®¡
        document.querySelector('.card-text').addEventListener('input', function() {
            adjustHeight();
            updateStats();
        });
        
        function updateTimestamp() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            document.querySelector('.timestamp').textContent = `${year}-${month}-${day} ${hours}:${minutes}`;
        }

        // é¡µé¢åŠ è½½æ—¶æ›´æ–°æ—¶é—´æˆ³
        updateTimestamp();
        
        function adjustHeight() {
            const mainPage = document.getElementById('mainPage');
            const contentHeight = document.querySelector('.content-wrapper').offsetHeight;
            mainPage.style.height = `${contentHeight + 100}px`; // é¢å¤–æ·»åŠ ä¸€äº›paddingç©ºé—´
        }

        // æ›´æ–° emoji æ˜¾ç¤º
        document.getElementById('emojiInput').addEventListener('input', function() {
            const emoji = this.value.trim().split(/\s+/)[0]; // åªå–ç¬¬ä¸€ä¸ªemoji
            const emojiContainer = document.querySelector('.emoji-container');
            // é‡å¤5æ¬¡
            emojiContainer.innerHTML = Array(5).fill(`<span class="emoji">${emoji}</span>`).join('');
        });

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–æ°´å°
        window.addEventListener('load', function() {
            updateStats();
        });

        // å¤„ç†å¤šä½™çš„ç©ºè¡Œ
        function normalizeEmptyLines(element) {
            // é€’å½’å¤„ç†æ‰€æœ‰å­å…ƒç´ 
            function processNode(node) {
                // å¦‚æœæ˜¯æ–‡æœ¬èŠ‚ç‚¹ï¼Œå»é™¤è¿ç»­çš„æ¢è¡Œ
                if (node.nodeType === Node.TEXT_NODE) {
                    node.textContent = node.textContent.replace(/\n{3,}/g, '\n\n');
                    return;
                }

                // å¤„ç†å—çº§å…ƒç´ ä¹‹é—´çš„é—´è·
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const style = window.getComputedStyle(node);
                    // å¦‚æœæ˜¯å—çº§å…ƒç´ ä¸”åªåŒ…å«ç©ºç™½
                    if (style.display === 'block' && node.textContent.trim() === '' && 
                        !node.querySelector('img, hr, br')) {
                        node.remove();
                        return;
                    }

                    // ç‰¹æ®Šå¤„ç†åˆ—è¡¨é¡¹
                    if (node.tagName === 'LI') {
                        // ç§»é™¤åˆ—è¡¨é¡¹å†…çš„ç©ºæ®µè½
                        const emptyParagraphs = node.querySelectorAll('p:empty, p:only-child');
                        emptyParagraphs.forEach(p => {
                            if (p.textContent.trim() === '') {
                                p.remove();
                            }
                        });
                    }

                    // ç§»é™¤æ‰€æœ‰å—çº§å…ƒç´ çš„è¾¹è·è®¾ç½®
                    if (node.tagName === 'P' || node.tagName === 'UL' || node.tagName === 'OL' || 
                        style.display === 'block') {
                        node.style.margin = '0';
                    }
                }

                // é€’å½’å¤„ç†å­å…ƒç´ 
                Array.from(node.childNodes).forEach(processNode);
            }

            // å¼€å§‹å¤„ç†
            processNode(element);

            // æœ€åæ¸…ç†ä»»ä½•å‰©ä½™çš„è¿ç»­ç©ºè¡Œ
            element.innerHTML = element.innerHTML.replace(/(<br\s*\/?>\s*){3,}/gi, '<br><br>');
            element.innerHTML = element.innerHTML.replace(/(<p>\s*<\/p>\s*){2,}/gi, '<p></p>');
        }

        function previewMarkdown() {
            const cardText = document.querySelector('.card-text');
            const renderedContent = document.querySelector('.rendered-content');
            const previewBtn = document.querySelector('.preview-btn');
            const generateBtn = document.querySelector('.generate-btn');
            
            // æ¸²æŸ“ Markdown
            let html = marked.parse(cardText.textContent);
            
            // å¤„ç†åˆ—è¡¨æ ‡ç­¾åçš„æ¢è¡Œ
            html = html
                .replace(/(<\/li>)\s*(?:\r\n|\n)?/g, '</li>')
                .replace(/(<\/ul>)\s*(?:\r\n|\n)?/g, '</ul>')
                .replace(/(<\/ol>)\s*(?:\r\n|\n)?/g, '</ol>')
                .replace(/(<li>)\s*(?:\r\n|\n)?/g, '<li>')
                .replace(/(<ul>)\s*(?:\r\n|\n)?/g, '<ul>')
                .replace(/(<ol>)\s*(?:\r\n|\n)?/g, '<ol>');
            
            renderedContent.innerHTML = html;
            
            // å¤„ç†å¤šä½™çš„ç©ºè¡Œ
            normalizeEmptyLines(renderedContent);
            
            // éšè—åŸæ–‡æœ¬ï¼Œæ˜¾ç¤ºæ¸²æŸ“åçš„å†…å®¹
            cardText.style.display = 'none';
            renderedContent.style.display = 'block';
            
            // åˆ‡æ¢æŒ‰é’®æ˜¾ç¤º
            previewBtn.textContent = 'è¿”å›ç¼–è¾‘';
            generateBtn.style.display = 'block';
            
            // æ›´æ”¹é¢„è§ˆæŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶
            previewBtn.onclick = function() {
                // æ¢å¤åŸå§‹æ˜¾ç¤ºçŠ¶æ€
                cardText.style.display = 'block';
                renderedContent.style.display = 'none';
                generateBtn.style.display = 'none';
                previewBtn.textContent = 'é¢„è§ˆæ¸²æŸ“æ•ˆæœ';
                previewBtn.onclick = previewMarkdown;
            };
            
            // ç¡®ä¿é«˜åº¦æ­£ç¡®
            adjustHeight();
        }

        // ä½¿ç”¨ Range API æ‰¾åˆ‡åˆ†ç‚¹
        function findSplitPointWithRange(container, startY, targetY) {
            try {
                const range = document.createRange();
                const walker = document.createTreeWalker(
                    container,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );

                let node;
                let lastGoodNode = null;
                let lastGoodOffset = 0;

                // éå†æ‰€æœ‰æ–‡æœ¬èŠ‚ç‚¹
                while (node = walker.nextNode()) {
                    const rects = range.setStart(node, 0) && range.getClientRects();
                    if (!rects.length) continue;

                    // å¦‚æœèŠ‚ç‚¹åœ¨ç›®æ ‡é«˜åº¦ä¹‹ä¸Šï¼Œè®°å½•å®ƒ
                    if (rects[0].top < targetY) {
                        lastGoodNode = node;
                        lastGoodOffset = node.length;
                    }

                    // å¦‚æœæ‰¾åˆ°è·¨è¶Šç›®æ ‡é«˜åº¦çš„èŠ‚ç‚¹
                    if (rects[0].bottom > targetY) {
                        // åœ¨è¿™ä¸ªèŠ‚ç‚¹ä¸­æ‰¾æœ€ä½³åˆ‡åˆ†ç‚¹
                        const text = node.textContent;
                        const punctuations = ['.', 'ã€‚', '!', 'ï¼', '?', 'ï¼Ÿ', ';', 'ï¼›'];
                        let bestOffset = 0;

                        // ä»åå‘å‰æŸ¥æ‰¾æ ‡ç‚¹
                        for (let i = text.length - 1; i >= 0; i--) {
                            range.setStart(node, i);
                            range.setEnd(node, i + 1);
                            const rect = range.getBoundingClientRect();
                            
                            if (rect.top < targetY) {
                                if (punctuations.includes(text[i])) {
                                    return {
                                        node: node,
                                        offset: i + 1
                                    };
                                }
                                // è®°å½•ç¬¬ä¸€ä¸ªåœ¨ç›®æ ‡é«˜åº¦ä¹‹ä¸‹çš„ä½ç½®
                                if (!bestOffset) {
                                    bestOffset = i + 1;
                                }
                            }
                        }

                        // å¦‚æœæ²¡æ‰¾åˆ°æ ‡ç‚¹ï¼Œä½¿ç”¨æœ€åä¸€ä¸ªåˆé€‚çš„ä½ç½®
                        if (bestOffset) {
                            return {
                                node: node,
                                offset: bestOffset
                            };
                        }
                    }
                }

                // å¦‚æœæ²¡æ‰¾åˆ°æ›´å¥½çš„ä½ç½®ï¼Œä½¿ç”¨æœ€åä¸€ä¸ªå¥½ä½ç½®
                if (lastGoodNode) {
                    return {
                        node: lastGoodNode,
                        offset: lastGoodOffset
                    };
                }

                return null;
            } catch (error) {
                console.error('Range API å¤±è´¥:', error);
                return null;
            }
        }

        // ä½¿ç”¨ ClientRects æ‰¾åˆ‡åˆ†ç‚¹
        function findSplitPointWithRects(container, startY, targetY) {
            try {
                const textNodes = [];
                const walker = document.createTreeWalker(
                    container,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );

                // æ”¶é›†æ‰€æœ‰æ–‡æœ¬èŠ‚ç‚¹
                let node;
                while (node = walker.nextNode()) {
                    const range = document.createRange();
                    range.selectNodeContents(node);
                    const rects = range.getClientRects();
                    
                    if (rects.length) {
                        textNodes.push({
                            node: node,
                            rects: Array.from(rects)
                        });
                    }
                }

                // æ‰¾åˆ°æœ€æ¥è¿‘ç›®æ ‡é«˜åº¦çš„å®Œæ•´è¡Œ
                let bestNode = null;
                let bestOffset = 0;
                let minDistance = Infinity;

                for (const {node, rects} of textNodes) {
                    for (let i = 0; i < rects.length; i++) {
                        const rect = rects[i];
                        const distance = Math.abs(rect.bottom - targetY);
                        
                        if (distance < minDistance && rect.bottom <= targetY) {
                            minDistance = distance;
                            bestNode = node;
                            bestOffset = node.length;
                        }
                    }
                }

                if (bestNode) {
                    return {
                        node: bestNode,
                        offset: bestOffset
                    };
                }

                return null;
            } catch (error) {
                console.error('ClientRects å¤±è´¥:', error);
                return null;
            }
        }

        // ç®€å•çš„å›ºå®šé«˜åº¦åˆ‡åˆ†
        function findSplitPointSimple(container, startY, targetY) {
            return {
                y: targetY
            };
        }

        // ä¸»åˆ‡åˆ†å‡½æ•°
        async function generateImage() {
            const mainPage = document.getElementById('mainPage');
            const imagePage = document.getElementById('imagePage');
            const buttonGroup = document.querySelector('.button-group');
            const settingsArea = document.querySelector('.settings-area');
            const buttonArea = document.querySelector('.button-area');
            
            // è·å–è®¾å¤‡å®½åº¦
            const deviceWidth = window.innerWidth;
            // è®¾ç½®æœ€å¤§å®½åº¦
            const maxWidth = Math.min(700, deviceWidth);
            // æ ¹æ®è®¾å¤‡å®½åº¦è°ƒæ•´é«˜åº¦æ¯”ä¾‹
            const FIXED_HEIGHT = Math.floor(1400 * (maxWidth / 700)); // æŒ‰æ¯”ä¾‹ç¼©æ”¾é«˜åº¦
            const WATERMARK_HEIGHT = Math.floor(60 * (maxWidth / 700)); // æŒ‰æ¯”ä¾‹ç¼©æ”¾æ°´å°é«˜åº¦
            const CONTENT_HEIGHT = FIXED_HEIGHT - WATERMARK_HEIGHT;
            
            try {
                // ç¡®ä¿é«˜åº¦æ­£ç¡®
                adjustHeight();
                
                // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨
                const contentElement = document.querySelector('.rendered-content');
                if (!contentElement) {
                    throw new Error('æ‰¾ä¸åˆ°æ¸²æŸ“å†…å®¹å…ƒç´ ');
                }

                // ç¡®ä¿å†…å®¹å·²æ¸²æŸ“
                if (contentElement.style.display === 'none') {
                    throw new Error('è¯·å…ˆç‚¹å‡»é¢„è§ˆæŒ‰é’®æŸ¥çœ‹æ¸²æŸ“æ•ˆæœ');
                }
                
                // æš‚æ—¶éšè—è®¾ç½®åŒºåŸŸå’ŒæŒ‰é’®
                buttonGroup.style.display = 'none';
                settingsArea.style.display = 'none';
                buttonArea.style.background = 'transparent';
                buttonArea.style.border = 'none';

                // ä½¿ç”¨html2canvasæ•è·é¡µé¢
                const canvas = await html2canvas(mainPage, {
                    backgroundColor: null,
                    scale: 2,
                    width: maxWidth, // è®¾ç½®ç”»å¸ƒå®½åº¦ä¸ºè®¾å¤‡å®½åº¦
                    height: mainPage.offsetHeight,
                    windowWidth: maxWidth, // è®¾ç½®çª—å£å®½åº¦ä¸ºè®¾å¤‡å®½åº¦
                    windowHeight: mainPage.offsetHeight,
                    useCORS: true,
                    onclone: function(clonedDoc) {
                        const clonedContent = clonedDoc.querySelector('.rendered-content');
                        if (clonedContent) {
                            clonedContent.style.color = '#c9d1d9';
                        }
                    }
                });

                // æ¸…ç©ºä¹‹å‰çš„å›¾ç‰‡
                const generatedImagesContainer = document.getElementById('generatedImages');
                generatedImagesContainer.innerHTML = '';

                // è®¡ç®—åˆ‡åˆ†ç‚¹
                let currentY = 0;
                const splitPoints = [];
                
                while (currentY < canvas.height) {
                    // å¦‚æœæ˜¯æœ€åä¸€éƒ¨åˆ†å†…å®¹
                    if (canvas.height - currentY <= CONTENT_HEIGHT) {
                        splitPoints.push({
                            start: currentY,
                            end: canvas.height,
                            needsPadding: true // æ ‡è®°éœ€è¦å¡«å……
                        });
                        break;
                    }
                    
                    // æ‰¾åˆ°æœ€ä½³åˆ‡åˆ†ç‚¹
                    let bestSplitPoint = currentY + CONTENT_HEIGHT;
                    let bestNode = null;
                    
                    for (const textNode of textNodes) {
                        const nodeTop = textNode.top * 2;
                        const nodeBottom = textNode.bottom * 2;
                        
                        // è·³è¿‡å·²å¤„ç†çš„èŠ‚ç‚¹
                        if (nodeBottom <= currentY) continue;
                        
                        // å¦‚æœæ‰¾åˆ°è·¨è¶Šç›®æ ‡é«˜åº¦çš„èŠ‚ç‚¹
                        if (nodeTop < bestSplitPoint && nodeBottom > bestSplitPoint) {
                            bestNode = textNode;
                            // åœ¨èŠ‚ç‚¹å†…æ‰¾æœ€åä¸€ä¸ªå¥å·
                            const text = textNode.text;
                            const punctuations = ['.', 'ã€‚', '!', 'ï¼', '?', 'ï¼Ÿ', ';', 'ï¼›'];
                            let lastPunctuationPos = -1;
                            
                            for (const punct of punctuations) {
                                const pos = text.lastIndexOf(punct);
                                if (pos > lastPunctuationPos) {
                                    lastPunctuationPos = pos;
                                }
                            }
                            
                            if (lastPunctuationPos !== -1) {
                                // å¦‚æœæ‰¾åˆ°å¥å·ï¼Œä½¿ç”¨å¥å·ä½ç½®
                                const ratio = lastPunctuationPos / text.length;
                                bestSplitPoint = nodeTop + (nodeBottom - nodeTop) * ratio;
                            } else {
                                // å¦‚æœæ²¡æ‰¾åˆ°å¥å·ï¼Œä½¿ç”¨èŠ‚ç‚¹èµ·å§‹ä½ç½®
                                bestSplitPoint = nodeTop;
                            }
                            break;
                        }
                    }
                    
                    splitPoints.push({
                        start: currentY,
                        end: bestSplitPoint,
                        needsPadding: false
                    });
                    
                    currentY = bestSplitPoint;
                }

                // ç”Ÿæˆå›¾ç‰‡
                for (let i = 0; i < splitPoints.length; i++) {
                    const splitPoint = splitPoints[i];
                    const tempCanvas = document.createElement('canvas');
                    const ctx = tempCanvas.getContext('2d');
                    
                    // è®¾ç½®å›ºå®šç”»å¸ƒé«˜åº¦
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = FIXED_HEIGHT;
                    
                    // å¡«å……èƒŒæ™¯
                    ctx.fillStyle = '#0d1117';
                    ctx.fillRect(0, 0, canvas.width, tempCanvas.height);
                    
                    // è®¡ç®—å®é™…å†…å®¹é«˜åº¦
                    const sourceHeight = splitPoint.end - splitPoint.start;
                    
                    // ç»˜åˆ¶å†…å®¹
                    ctx.drawImage(
                        canvas,
                        0, splitPoint.start,
                        canvas.width, sourceHeight,
                        0, 0,
                        canvas.width, sourceHeight
                    );
                    
                    // æ·»åŠ æ°´å°
                    const watermarkText = document.getElementById('watermarkInput').value || 'æ°´å°';
                    ctx.font = 'italic 18px -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif';
                    ctx.fillStyle = 'rgba(201, 209, 217, 0.8)';
                    ctx.textAlign = 'center';
                    ctx.fillText(watermarkText, canvas.width / 2, FIXED_HEIGHT - (WATERMARK_HEIGHT / 2));
                    
                    // åˆ›å»ºå›¾ç‰‡
                    const img = document.createElement('img');
                    img.className = 'generated-image';
                    img.style.marginBottom = '20px';
                    img.src = tempCanvas.toDataURL('image/png');
                    generatedImagesContainer.appendChild(img);
                }
                
                // åˆ‡æ¢æ˜¾ç¤º
                mainPage.style.display = 'none';
                imagePage.style.display = 'flex';
                
            } catch (error) {
                console.error('ç”Ÿæˆå›¾ç‰‡å¤±è´¥:', error);
                alert(`ç”Ÿæˆå›¾ç‰‡å¤±è´¥: ${error.message}`);
            } finally {
                // æ¢å¤åŸå§‹æ˜¾ç¤ºçŠ¶æ€
                buttonGroup.style.display = 'flex';
                settingsArea.style.display = 'flex';
                buttonArea.style.background = '#161b22';
                buttonArea.style.borderBottom = '1px solid #30363d';
            }
        }

        // é…ç½® marked é€‰é¡¹
        marked.setOptions({
            breaks: true,  // æ”¯æŒ GitHub é£æ ¼çš„æ¢è¡Œ
            gfm: true,    // å¯ç”¨ GitHub é£æ ¼çš„ Markdown
            headerIds: false,  // ç¦ç”¨æ ‡é¢˜ ID
            mangle: false,    // ç¦ç”¨æ ‡é¢˜ ID è½¬ä¹‰
            langPrefix: '',   // ä¸æ·»åŠ  language- å‰ç¼€
        });

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats() {
            const watermarkText = document.getElementById('watermarkInput').value || 'æ°´å°';
            document.querySelector('.stats').innerHTML = `<span>${watermarkText}</span>`;
        }

        // ç›‘å¬æ°´å°è¾“å…¥å˜åŒ–
        document.getElementById('watermarkInput').addEventListener('input', function() {
            updateStats();
        });

        // åˆå§‹è°ƒæ•´é«˜åº¦å’Œæ›´æ–°ç»Ÿè®¡
        adjustHeight();
        updateStats();

        // æ·»åŠ ä¸‹è½½å‡½æ•°
        async function downloadAllImages() {
            const images = document.querySelectorAll('.generated-image');
            if (images.length === 0) {
                alert('æ²¡æœ‰å¯ä¸‹è½½çš„å›¾ç‰‡');
                return;
            }

            // åˆ›å»ºä¸€ä¸ªä¸‹è½½é“¾æ¥
            const downloadLink = document.createElement('a');
            downloadLink.style.display = 'none';
            document.body.appendChild(downloadLink);

            // ä¸‹è½½æ‰€æœ‰å›¾ç‰‡
            for (let i = 0; i < images.length; i++) {
                const image = images[i];
                const imageName = `split-${i + 1}.png`;

                // ä» base64 URL åˆ›å»º Blob
                const response = await fetch(image.src);
                const blob = await response.blob();
                
                // åˆ›å»ºä¸‹è½½ URL
                const url = window.URL.createObjectURL(blob);
                
                // è®¾ç½®ä¸‹è½½é“¾æ¥
                downloadLink.href = url;
                downloadLink.download = imageName;
                
                // è§¦å‘ä¸‹è½½
                downloadLink.click();
                
                // æ¸…ç† URL
                window.URL.revokeObjectURL(url);
            }

            // ç§»é™¤ä¸‹è½½é“¾æ¥
            document.body.removeChild(downloadLink);
        }
    </script>
</body>
</html>