<!-- Version 1.4 -->
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1. ç”Ÿæˆå›¾ç‰‡-2.é•¿æŒ‰å›¾ç‰‡ä¿å­˜</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background: #0d1117;  /* GitHub æ·±è‰²æ¨¡å¼èƒŒæ™¯è‰² */
        }

        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            background: #0d1117;
        }

        #mainPage {
            width: 700px;  /* æ”¹ä¸º 700px */
            min-height: fit-content;
            background: #0d1117;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            margin: 0 auto;  /* å±…ä¸­æ˜¾ç¤º */
        }

        .button-area {
            width: 700px;
            background: #161b22;
            border-bottom: 1px solid #30363d;
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            margin-bottom: 0;  /* ç¡®ä¿æ²¡æœ‰åº•éƒ¨è¾¹è· */
        }

        .settings-area {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input-group label {
            color: #c9d1d9;
            font-size: 14px;
        }

        .input-group input {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            padding: 4px 8px;
            font-size: 14px;
            width: 200px;
        }

        .content-area {
            width: 700px;
            padding: 0 10px;  /* ç§»é™¤é¡¶éƒ¨å†…è¾¹è· */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .content-wrapper {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;  /* ç§»é™¤é—´è· */
        }

        .emoji-container {
            width: 100%;
            display: flex;
            justify-content: space-evenly;
            padding: 0;  /* ç§»é™¤å†…è¾¹è· */
            margin-bottom: 5px;  /* åªä¿ç•™åº•éƒ¨ä¸€ç‚¹é—´è· */
        }

        .emoji {
            font-size: 24px;
        }

        .card {
            width: 650px;  /* æ”¹ä¸º 650px */
            padding: 16px;
            background: #161b22;  /* GitHub æ·±è‰²æ¨¡å¼å¡ç‰‡èƒŒæ™¯è‰² */
            border: 1px solid #30363d;  /* GitHub æ·±è‰²æ¨¡å¼è¾¹æ¡† */
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            color: #c9d1d9 !important;  /* GitHub æ·±è‰²æ¨¡å¼æ–‡æœ¬é¢œè‰² */
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .timestamp {
            font-size: 14px;
            color: #8b949e;  /* GitHub æ·±è‰²æ¨¡å¼æ¬¡è¦æ–‡æœ¬é¢œè‰² */
            text-align: center;
            margin-bottom: 16px;
        }

        .stats {
            display: none;  /* éšè—ç»Ÿè®¡ä¿¡æ¯ */
        }

        .card-text, .rendered-content {
            font-size: 16px;
            line-height: 1.5;
            color: #c9d1d9;
            text-align: left;
            min-height: 100px;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            width: 100%;
            display: block;
            max-width: 100%;
            overflow: auto;
        }

        /* Markdown æ ·å¼ */
        .card-text ul, .card-text ol,
        .rendered-content ul, .rendered-content ol {
            margin: 0 !important;
            padding-left: 2em;
        }

        .card-text ul ul, .rendered-content ul ul {
            list-style-type: circle;
            margin: 0 !important;
        }

        .card-text li, .rendered-content li {
            margin: 0.4em 0;
        }

        .card-text pre, .rendered-content pre {
            font-size: 14px;
            line-height: 1.45;
            background-color: #0d1117;
            padding: 16px;
            border-radius: 6px;
            border: 1px solid #30363d;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #c9d1d9;
            margin: 0.8em 0 !important;
        }

        .card-text code, .rendered-content code {
            font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
            font-size: 14px;
            padding: 0.2em 0.4em;
            background-color: rgba(110,118,129,0.4);
            border-radius: 6px;
            color: #c9d1d9;
        }

        .card-text p, .rendered-content p {
            margin: 0 !important;
        }

        .card-text h1, .card-text h2, .card-text h3, .card-text h4, .card-text h5, .card-text h6,
        .rendered-content h1, .rendered-content h2, .rendered-content h3, .rendered-content h4, .rendered-content h5, .rendered-content h6 {
            margin: 0.5em 0 0.3em !important;
            line-height: 1.3;
        }

        /* ç‰¹æ®Šå¤„ç†æ®µè½åé¢ç´§è·Ÿçš„æ ‡é¢˜ */
        .card-text p + h1, .card-text p + h2, .card-text p + h3, .card-text p + h4, .card-text p + h5, .card-text p + h6,
        .rendered-content p + h1, .rendered-content p + h2, .rendered-content p + h3, .rendered-content p + h4, .rendered-content p + h5, .rendered-content p + h6 {
            margin-top: 0.3em !important;
        }

        .card-text blockquote, .rendered-content blockquote {
            margin: 0.8em 0 !important;
            padding: 0.4em 1em;
            border-left: 0.25em solid #30363d;
            color: #8b949e;
        }

        .card-text table, .rendered-content table {
            margin: 0.8em 0;
            width: 100%;
            border-collapse: collapse;
            border: 1px solid #30363d;
        }

        .card-text td, .card-text th,
        .rendered-content td, .rendered-content th {
            padding: 8px;
            text-align: left;
            border: 1px solid #30363d;
        }

        .card-text pre code, .rendered-content pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
        }

        /* æ›´æ–°æ°´å°æ ·å¼ */
        .watermark {
            display: none;  /* éšè—åŸå§‹æ°´å° */
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .preview-btn, .generate-btn {
            background: #238636;
            color: #ffffff;
            border: 1px solid rgba(240,246,252,0.1);
            padding: 5px 16px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .preview-btn:hover, .generate-btn:hover {
            background: #2ea043;
        }

        #imagePage {
            background: #0d1117;  /* GitHub æ·±è‰²æ¨¡å¼èƒŒæ™¯è‰² */
            display: none;
            width: 700px;  /* æ”¹ä¸º 700px */
            min-height: 100vh;
            padding: 40px 20px;
            flex-direction: column;
            align-items: center;
            margin: 0 auto;  /* å±…ä¸­æ˜¾ç¤º */
        }

        .save-hint {
            color: #c9d1d9;  /* GitHub æ·±è‰²æ¨¡å¼æ–‡æœ¬é¢œè‰² */
            font-size: 18px;
            margin: 20px 0;
        }

        .generated-image {
            max-width: 100%;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .download-btn {
            background: #238636;
            color: #ffffff;
            border: 1px solid rgba(240,246,252,0.1);
            padding: 5px 16px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            margin: 20px 0;
        }

        .download-btn:hover {
            background: #2ea043;
        }
    </style>
</head>
<body>
    <div id="mainPage">
        <div class="button-area">
            <div class="settings-area">
                <div class="input-group">
                    <label for="emojiInput">è¡¨æƒ…ç¬¦å·:</label>
                    <input type="text" id="emojiInput" value="ğŸ± ğŸ± ğŸ± ğŸ± ğŸ±" placeholder="è¾“å…¥è¡¨æƒ…ç¬¦å·">
                </div>
                <div class="input-group">
                    <label for="watermarkInput">æ°´å°æ–‡æœ¬:</label>
                    <input type="text" id="watermarkInput" value="æ°´å°" placeholder="è¾“å…¥æ°´å°æ–‡æœ¬">
                </div>
            </div>
            <div class="button-group">
                <button class="preview-btn" onclick="previewMarkdown()">é¢„è§ˆæ¸²æŸ“æ•ˆæœ</button>
                <button class="generate-btn" onclick="generateImage()" style="display: none;">ç”Ÿæˆå›¾ç‰‡</button>
                <a href="../index.html" style="color: #8b949e; text-decoration: none; margin-left: 20px;">è¿”å›ä¸»é¡µ</a>
            </div>
        </div>
        <div class="content-area">
            <div class="content-wrapper">
                <div class="emoji-container">
                    <span class="emoji">ğŸ±</span>
                    <span class="emoji">ğŸ±</span>
                    <span class="emoji">ğŸ±</span>
                    <span class="emoji">ğŸ±</span>
                    <span class="emoji">ğŸ±</span>
                </div>
                <div class="card">
                    <div class="timestamp"></div>
                    <div class="card-text" contenteditable="true">æ­£æ–‡</div>
                    <div class="rendered-content" style="display: none;"></div>
                    <div class="stats"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="imagePage">
        <div class="button-group">
            <button class="download-btn" onclick="downloadAllImages()">ä¸‹è½½å…¨éƒ¨å›¾ç‰‡</button>
            <a href="../index.html" style="color: #8b949e; text-decoration: none; margin-left: 20px;">è¿”å›ä¸»é¡µ</a>
        </div>
        <div id="generatedImages"></div>
    </div>

    <script>
        // ç›‘å¬æ–‡æœ¬å˜åŒ–ï¼Œè°ƒæ•´å®¹å™¨é«˜åº¦å’Œæ›´æ–°å­—æ•°ç»Ÿè®¡
        document.querySelector('.card-text').addEventListener('input', function() {
            adjustHeight();
            updateStats();
        });
        
        function updateTimestamp() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            document.querySelector('.timestamp').textContent = `${year}-${month}-${day} ${hours}:${minutes}`;
        }

        // é¡µé¢åŠ è½½æ—¶æ›´æ–°æ—¶é—´æˆ³
        updateTimestamp();
        
        function adjustHeight() {
            const mainPage = document.getElementById('mainPage');
            const contentHeight = document.querySelector('.content-wrapper').offsetHeight;
            mainPage.style.height = `${contentHeight + 100}px`; // é¢å¤–æ·»åŠ ä¸€äº›paddingç©ºé—´
        }

        // æ›´æ–° emoji æ˜¾ç¤º
        document.getElementById('emojiInput').addEventListener('input', function() {
            const emoji = this.value.trim().split(/\s+/)[0]; // åªå–ç¬¬ä¸€ä¸ªemoji
            const emojiContainer = document.querySelector('.emoji-container');
            // é‡å¤5æ¬¡
            emojiContainer.innerHTML = Array(5).fill(`<span class="emoji">${emoji}</span>`).join('');
        });

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–æ°´å°
        window.addEventListener('load', function() {
            updateStats();
        });

        // å¤„ç†å¤šä½™çš„ç©ºè¡Œ
        function normalizeEmptyLines(element) {
            // é€’å½’å¤„ç†æ‰€æœ‰å­å…ƒç´ 
            function processNode(node) {
                // å¦‚æœæ˜¯æ–‡æœ¬èŠ‚ç‚¹ï¼Œå»é™¤è¿ç»­çš„æ¢è¡Œ
                if (node.nodeType === Node.TEXT_NODE) {
                    node.textContent = node.textContent.replace(/\n{3,}/g, '\n\n');
                    return;
                }

                // å¤„ç†å—çº§å…ƒç´ ä¹‹é—´çš„é—´è·
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const style = window.getComputedStyle(node);
                    // å¦‚æœæ˜¯å—çº§å…ƒç´ ä¸”åªåŒ…å«ç©ºç™½
                    if (style.display === 'block' && node.textContent.trim() === '' && 
                        !node.querySelector('img, hr, br')) {
                        node.remove();
                        return;
                    }

                    // ç‰¹æ®Šå¤„ç†åˆ—è¡¨é¡¹
                    if (node.tagName === 'LI') {
                        // ç§»é™¤åˆ—è¡¨é¡¹å†…çš„ç©ºæ®µè½
                        const emptyParagraphs = node.querySelectorAll('p:empty, p:only-child');
                        emptyParagraphs.forEach(p => {
                            if (p.textContent.trim() === '') {
                                p.remove();
                            }
                        });
                    }

                    // ç§»é™¤æ‰€æœ‰å—çº§å…ƒç´ çš„è¾¹è·è®¾ç½®
                    if (node.tagName === 'P' || node.tagName === 'UL' || node.tagName === 'OL' || 
                        style.display === 'block') {
                        node.style.margin = '0';
                    }
                }

                // é€’å½’å¤„ç†å­å…ƒç´ 
                Array.from(node.childNodes).forEach(processNode);
            }

            // å¼€å§‹å¤„ç†
            processNode(element);

            // æœ€åæ¸…ç†ä»»ä½•å‰©ä½™çš„è¿ç»­ç©ºè¡Œ
            element.innerHTML = element.innerHTML.replace(/(<br\s*\/?>\s*){3,}/gi, '<br><br>');
            element.innerHTML = element.innerHTML.replace(/(<p>\s*<\/p>\s*){2,}/gi, '<p></p>');
        }

        function previewMarkdown() {
            const cardText = document.querySelector('.card-text');
            const renderedContent = document.querySelector('.rendered-content');
            const previewBtn = document.querySelector('.preview-btn');
            const generateBtn = document.querySelector('.generate-btn');
            
            // æ¸²æŸ“ Markdown
            let html = marked.parse(cardText.textContent);
            
            // å¤„ç†åˆ—è¡¨æ ‡ç­¾åçš„æ¢è¡Œ
            html = html
                .replace(/(<\/li>)\s*(?:\r\n|\n)?/g, '</li>')
                .replace(/(<\/ul>)\s*(?:\r\n|\n)?/g, '</ul>')
                .replace(/(<\/ol>)\s*(?:\r\n|\n)?/g, '</ol>')
                .replace(/(<li>)\s*(?:\r\n|\n)?/g, '<li>')
                .replace(/(<ul>)\s*(?:\r\n|\n)?/g, '<ul>')
                .replace(/(<ol>)\s*(?:\r\n|\n)?/g, '<ol>');
            
            renderedContent.innerHTML = html;
            
            // å¤„ç†å¤šä½™çš„ç©ºè¡Œ
            normalizeEmptyLines(renderedContent);
            
            // éšè—åŸæ–‡æœ¬ï¼Œæ˜¾ç¤ºæ¸²æŸ“åçš„å†…å®¹
            cardText.style.display = 'none';
            renderedContent.style.display = 'block';
            
            // åˆ‡æ¢æŒ‰é’®æ˜¾ç¤º
            previewBtn.textContent = 'è¿”å›ç¼–è¾‘';
            generateBtn.style.display = 'block';
            
            // æ›´æ”¹é¢„è§ˆæŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶
            previewBtn.onclick = function() {
                // æ¢å¤åŸå§‹æ˜¾ç¤ºçŠ¶æ€
                cardText.style.display = 'block';
                renderedContent.style.display = 'none';
                generateBtn.style.display = 'none';
                previewBtn.textContent = 'é¢„è§ˆæ¸²æŸ“æ•ˆæœ';
                previewBtn.onclick = previewMarkdown;
            };
            
            // ç¡®ä¿é«˜åº¦æ­£ç¡®
            adjustHeight();
        }

        // ä½¿ç”¨ Range API æ‰¾åˆ‡åˆ†ç‚¹
        function findSplitPointWithRange(container, startY, targetY) {
            try {
                const range = document.createRange();
                const walker = document.createTreeWalker(
                    container,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );

                let node;
                let lastGoodNode = null;
                let lastGoodOffset = 0;

                // éå†æ‰€æœ‰æ–‡æœ¬èŠ‚ç‚¹
                while (node = walker.nextNode()) {
                    const rects = range.setStart(node, 0) && range.getClientRects();
                    if (!rects.length) continue;

                    // å¦‚æœèŠ‚ç‚¹åœ¨ç›®æ ‡é«˜åº¦ä¹‹ä¸Šï¼Œè®°å½•å®ƒ
                    if (rects[0].top < targetY) {
                        lastGoodNode = node;
                        lastGoodOffset = node.length;
                    }

                    // å¦‚æœæ‰¾åˆ°è·¨è¶Šç›®æ ‡é«˜åº¦çš„èŠ‚ç‚¹
                    if (rects[0].bottom > targetY) {
                        // åœ¨è¿™ä¸ªèŠ‚ç‚¹ä¸­æ‰¾æœ€ä½³åˆ‡åˆ†ç‚¹
                        const text = node.textContent;
                        const punctuations = ['.', 'ã€‚', '!', 'ï¼', '?', 'ï¼Ÿ', ';', 'ï¼›'];
                        let bestOffset = 0;

                        // ä»åå‘å‰æŸ¥æ‰¾æ ‡ç‚¹
                        for (let i = text.length - 1; i >= 0; i--) {
                            range.setStart(node, i);
                            range.setEnd(node, i + 1);
                            const rect = range.getBoundingClientRect();
                            
                            if (rect.top < targetY) {
                                if (punctuations.includes(text[i])) {
                                    return {
                                        node: node,
                                        offset: i + 1
                                    };
                                }
                                // è®°å½•ç¬¬ä¸€ä¸ªåœ¨ç›®æ ‡é«˜åº¦ä¹‹ä¸‹çš„ä½ç½®
                                if (!bestOffset) {
                                    bestOffset = i + 1;
                                }
                            }
                        }

                        // å¦‚æœæ²¡æ‰¾åˆ°æ ‡ç‚¹ï¼Œä½¿ç”¨æœ€åä¸€ä¸ªåˆé€‚çš„ä½ç½®
                        if (bestOffset) {
                            return {
                                node: node,
                                offset: bestOffset
                            };
                        }
                    }
                }

                // å¦‚æœæ²¡æ‰¾åˆ°æ›´å¥½çš„ä½ç½®ï¼Œä½¿ç”¨æœ€åä¸€ä¸ªå¥½ä½ç½®
                if (lastGoodNode) {
                    return {
                        node: lastGoodNode,
                        offset: lastGoodOffset
                    };
                }

                return null;
            } catch (error) {
                console.error('Range API å¤±è´¥:', error);
                return null;
            }
        }

        // ä½¿ç”¨ ClientRects æ‰¾åˆ‡åˆ†ç‚¹
        function findSplitPointWithRects(container, startY, targetY) {
            try {
                const textNodes = [];
                const walker = document.createTreeWalker(
                    container,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );

                // æ”¶é›†æ‰€æœ‰æ–‡æœ¬èŠ‚ç‚¹
                let node;
                while (node = walker.nextNode()) {
                    const range = document.createRange();
                    range.selectNodeContents(node);
                    const rects = range.getClientRects();
                    
                    if (rects.length) {
                        textNodes.push({
                            node: node,
                            rects: Array.from(rects)
                        });
                    }
                }

                // æ‰¾åˆ°æœ€æ¥è¿‘ç›®æ ‡é«˜åº¦çš„å®Œæ•´è¡Œ
                let bestNode = null;
                let bestOffset = 0;
                let minDistance = Infinity;

                for (const {node, rects} of textNodes) {
                    for (let i = 0; i < rects.length; i++) {
                        const rect = rects[i];
                        const distance = Math.abs(rect.bottom - targetY);
                        
                        if (distance < minDistance && rect.bottom <= targetY) {
                            minDistance = distance;
                            bestNode = node;
                            bestOffset = node.length;
                        }
                    }
                }

                if (bestNode) {
                    return {
                        node: bestNode,
                        offset: bestOffset
                    };
                }

                return null;
            } catch (error) {
                console.error('ClientRects å¤±è´¥:', error);
                return null;
            }
        }

        // ç®€å•çš„å›ºå®šé«˜åº¦åˆ‡åˆ†
        function findSplitPointSimple(container, startY, targetY) {
            return {
                y: targetY
            };
        }

        // ä¸»åˆ‡åˆ†å‡½æ•°
        async function generateImage() {
            const mainPage = document.getElementById('mainPage');
            const imagePage = document.getElementById('imagePage');
            const buttonGroup = document.querySelector('.button-group');
            const settingsArea = document.querySelector('.settings-area');
            const buttonArea = document.querySelector('.button-area');
            const FIXED_HEIGHT = 1400; // å›ºå®šé«˜åº¦
            const WATERMARK_HEIGHT = 60; // æ°´å°é«˜åº¦
            const CONTENT_HEIGHT = FIXED_HEIGHT - WATERMARK_HEIGHT; // å†…å®¹åŒºåŸŸé«˜åº¦
            
            try {
                // ç¡®ä¿é«˜åº¦æ­£ç¡®
                adjustHeight();
                
                // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨
                const contentElement = document.querySelector('.rendered-content');
                if (!contentElement) {
                    throw new Error('æ‰¾ä¸åˆ°æ¸²æŸ“å†…å®¹å…ƒç´ ');
                }

                // ç¡®ä¿å†…å®¹å·²æ¸²æŸ“
                if (contentElement.style.display === 'none') {
                    throw new Error('è¯·å…ˆç‚¹å‡»é¢„è§ˆæŒ‰é’®æŸ¥çœ‹æ¸²æŸ“æ•ˆæœ');
                }
                
                // æš‚æ—¶éšè—è®¾ç½®åŒºåŸŸå’ŒæŒ‰é’®
                buttonGroup.style.display = 'none';
                settingsArea.style.display = 'none';
                buttonArea.style.background = 'transparent';
                buttonArea.style.border = 'none';

                // è·å–æ‰€æœ‰æ–‡æœ¬èŠ‚ç‚¹åŠå…¶ä½ç½®
                const textNodes = [];
                const walker = document.createTreeWalker(
                    contentElement,
                    NodeFilter.SHOW_TEXT,
                    {
                        acceptNode: function(node) {
                            // è·³è¿‡ç©ºç™½èŠ‚ç‚¹
                            return node.textContent.trim() ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                        }
                    }
                );

                let node;
                while (node = walker.nextNode()) {
                    const range = document.createRange();
                    range.selectNodeContents(node);
                    const rects = range.getClientRects();
                    if (rects.length > 0) {
                        textNodes.push({
                            node: node,
                            top: rects[0].top,
                            bottom: rects[rects.length - 1].bottom,
                            height: rects[rects.length - 1].bottom - rects[0].top,
                            text: node.textContent
                        });
                    }
                }

                // æŒ‰ä½ç½®æ’åº
                textNodes.sort((a, b) => a.top - b.top);

                // ä½¿ç”¨html2canvasæ•è·é¡µé¢
                const canvas = await html2canvas(mainPage, {
                    backgroundColor: null,
                    scale: 2,
                    height: mainPage.offsetHeight,
                    windowHeight: mainPage.offsetHeight,
                    useCORS: true,
                    onclone: function(clonedDoc) {
                        const clonedContent = clonedDoc.querySelector('.rendered-content');
                        if (clonedContent) {
                            clonedContent.style.color = '#c9d1d9';
                        }
                    }
                });

                // æ¸…ç©ºä¹‹å‰çš„å›¾ç‰‡
                const generatedImagesContainer = document.getElementById('generatedImages');
                generatedImagesContainer.innerHTML = '';

                // è®¡ç®—åˆ‡åˆ†ç‚¹
                let currentY = 0;
                const splitPoints = [];
                
                while (currentY < canvas.height) {
                    // å¦‚æœæ˜¯æœ€åä¸€éƒ¨åˆ†å†…å®¹
                    if (canvas.height - currentY <= CONTENT_HEIGHT) {
                        splitPoints.push({
                            start: currentY,
                            end: canvas.height,
                            needsPadding: true // æ ‡è®°éœ€è¦å¡«å……
                        });
                        break;
                    }
                    
                    // æ‰¾åˆ°æœ€ä½³åˆ‡åˆ†ç‚¹
                    let bestSplitPoint = currentY + CONTENT_HEIGHT;
                    let bestNode = null;
                    
                    for (const textNode of textNodes) {
                        const nodeTop = textNode.top * 2;
                        const nodeBottom = textNode.bottom * 2;
                        
                        // è·³è¿‡å·²å¤„ç†çš„èŠ‚ç‚¹
                        if (nodeBottom <= currentY) continue;
                        
                        // å¦‚æœæ‰¾åˆ°è·¨è¶Šç›®æ ‡é«˜åº¦çš„èŠ‚ç‚¹
                        if (nodeTop < bestSplitPoint && nodeBottom > bestSplitPoint) {
                            bestNode = textNode;
                            // åœ¨èŠ‚ç‚¹å†…æ‰¾æœ€åä¸€ä¸ªå¥å·
                            const text = textNode.text;
                            const punctuations = ['.', 'ã€‚', '!', 'ï¼', '?', 'ï¼Ÿ', ';', 'ï¼›'];
                            let lastPunctuationPos = -1;
                            
                            for (const punct of punctuations) {
                                const pos = text.lastIndexOf(punct);
                                if (pos > lastPunctuationPos) {
                                    lastPunctuationPos = pos;
                                }
                            }
                            
                            if (lastPunctuationPos !== -1) {
                                // å¦‚æœæ‰¾åˆ°å¥å·ï¼Œä½¿ç”¨å¥å·ä½ç½®
                                const ratio = lastPunctuationPos / text.length;
                                bestSplitPoint = nodeTop + (nodeBottom - nodeTop) * ratio;
                            } else {
                                // å¦‚æœæ²¡æ‰¾åˆ°å¥å·ï¼Œä½¿ç”¨èŠ‚ç‚¹èµ·å§‹ä½ç½®
                                bestSplitPoint = nodeTop;
                            }
                            break;
                        }
                    }
                    
                    splitPoints.push({
                        start: currentY,
                        end: bestSplitPoint,
                        needsPadding: false
                    });
                    
                    currentY = bestSplitPoint;
                }

                // ç”Ÿæˆå›¾ç‰‡
                for (let i = 0; i < splitPoints.length; i++) {
                    const splitPoint = splitPoints[i];
                    const tempCanvas = document.createElement('canvas');
                    const ctx = tempCanvas.getContext('2d');
                    
                    // è®¾ç½®å›ºå®šç”»å¸ƒé«˜åº¦
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = FIXED_HEIGHT;
                    
                    // å¡«å……èƒŒæ™¯
                    ctx.fillStyle = '#0d1117';
                    ctx.fillRect(0, 0, canvas.width, tempCanvas.height);
                    
                    // è®¡ç®—å®é™…å†…å®¹é«˜åº¦
                    const sourceHeight = splitPoint.end - splitPoint.start;
                    
                    // ç»˜åˆ¶å†…å®¹
                    ctx.drawImage(
                        canvas,
                        0, splitPoint.start,
                        canvas.width, sourceHeight,
                        0, 0,
                        canvas.width, sourceHeight
                    );
                    
                    // æ·»åŠ æ°´å°
                    const watermarkText = document.getElementById('watermarkInput').value || 'æ°´å°';
                    ctx.font = 'italic 18px -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif';
                    ctx.fillStyle = 'rgba(201, 209, 217, 0.8)';
                    ctx.textAlign = 'center';
                    ctx.fillText(watermarkText, canvas.width / 2, FIXED_HEIGHT - (WATERMARK_HEIGHT / 2));
                    
                    // åˆ›å»ºå›¾ç‰‡
                    const img = document.createElement('img');
                    img.className = 'generated-image';
                    img.style.marginBottom = '20px';
                    img.src = tempCanvas.toDataURL('image/png');
                    generatedImagesContainer.appendChild(img);
                }
                
                // åˆ‡æ¢æ˜¾ç¤º
                mainPage.style.display = 'none';
                imagePage.style.display = 'flex';
                
            } catch (error) {
                console.error('ç”Ÿæˆå›¾ç‰‡å¤±è´¥:', error);
                alert(`ç”Ÿæˆå›¾ç‰‡å¤±è´¥: ${error.message}`);
            } finally {
                // æ¢å¤åŸå§‹æ˜¾ç¤ºçŠ¶æ€
                buttonGroup.style.display = 'flex';
                settingsArea.style.display = 'flex';
                buttonArea.style.background = '#161b22';
                buttonArea.style.borderBottom = '1px solid #30363d';
            }
        }

        // é…ç½® marked é€‰é¡¹
        marked.setOptions({
            breaks: true,  // æ”¯æŒ GitHub é£æ ¼çš„æ¢è¡Œ
            gfm: true,    // å¯ç”¨ GitHub é£æ ¼çš„ Markdown
            headerIds: false,  // ç¦ç”¨æ ‡é¢˜ ID
            mangle: false,    // ç¦ç”¨æ ‡é¢˜ ID è½¬ä¹‰
            langPrefix: '',   // ä¸æ·»åŠ  language- å‰ç¼€
        });

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats() {
            const watermarkText = document.getElementById('watermarkInput').value || 'æ°´å°';
            document.querySelector('.stats').innerHTML = `<span>${watermarkText}</span>`;
        }

        // ç›‘å¬æ°´å°è¾“å…¥å˜åŒ–
        document.getElementById('watermarkInput').addEventListener('input', function() {
            updateStats();
        });

        // åˆå§‹è°ƒæ•´é«˜åº¦å’Œæ›´æ–°ç»Ÿè®¡
        adjustHeight();
        updateStats();

        // æ·»åŠ ä¸‹è½½å‡½æ•°
        async function downloadAllImages() {
            const images = document.querySelectorAll('.generated-image');
            if (images.length === 0) {
                alert('æ²¡æœ‰å¯ä¸‹è½½çš„å›¾ç‰‡');
                return;
            }

            // åˆ›å»ºä¸€ä¸ªä¸‹è½½é“¾æ¥
            const downloadLink = document.createElement('a');
            downloadLink.style.display = 'none';
            document.body.appendChild(downloadLink);

            // ä¸‹è½½æ‰€æœ‰å›¾ç‰‡
            for (let i = 0; i < images.length; i++) {
                const image = images[i];
                const imageName = `split-${i + 1}.png`;

                // ä» base64 URL åˆ›å»º Blob
                const response = await fetch(image.src);
                const blob = await response.blob();
                
                // åˆ›å»ºä¸‹è½½ URL
                const url = window.URL.createObjectURL(blob);
                
                // è®¾ç½®ä¸‹è½½é“¾æ¥
                downloadLink.href = url;
                downloadLink.download = imageName;
                
                // è§¦å‘ä¸‹è½½
                downloadLink.click();
                
                // æ¸…ç† URL
                window.URL.revokeObjectURL(url);
            }

            // ç§»é™¤ä¸‹è½½é“¾æ¥
            document.body.removeChild(downloadLink);
        }
    </script>
</body>
</html>